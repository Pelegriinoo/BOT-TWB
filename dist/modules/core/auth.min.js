window.AuthManager = class AuthManager {constructor(api) {this.api = api;this.tokenCache = new Map();this.tokenExpiration = 30 * 60 * 1000; }async getCSRFToken(villageId = null) {const village = villageId || this.api.currentVillage;const cacheKey = `token_${village}`;const cachedToken = this.getCachedToken(cacheKey);if (cachedToken) {return cachedToken;}let token = this.extractTokenFromCurrentPage();if (token) {this.setCachedToken(cacheKey, token);return token;}token = await this.fetchTokenFromServer(village);if (token) {this.setCachedToken(cacheKey, token);return token;}throw new Error('Não foi possível obter token CSRF');}extractTokenFromCurrentPage() {const hiddenInput = document.querySelector('input[name="h"]');if (hiddenInput?.value) {return hiddenInput.value;}const urlParams = new URLSearchParams(window.location.search);const urlToken = urlParams.get('h');if (urlToken) {return urlToken;}const pageHTML = document.documentElement.innerHTML;let match = pageHTML.match(/[&?]h=([a-f0-9]+)/);if (match) return match[1];match = pageHTML.match(/['"]h['"]:\s*['"]([^'"]+)['"]/);if (match) return match[1];match = pageHTML.match(/data-h=['"]([^'"]+)['"]/);if (match) return match[1];return null;}async fetchTokenFromServer(villageId) {try {const pages = ['place', 'overview', 'main'];for (const screen of pages) {try {const html = await this.api.get({village: villageId,screen});const token = this.extractTokenFromHTML(html);if (token) {return token;}} catch (error) {console.warn(`Erro ao buscar token na tela ${screen}:`, error.message);}}return null;} catch (error) {console.error('Erro ao buscar token do servidor:', error);return null;}}extractTokenFromHTML(html) {let match = html.match(/name="h"\s+value="([^"]+)"/);if (match) return match[1];match = html.match(/value="([^"]+)"\s+name="h"/);if (match) return match[1];match = html.match(/[&?]h=([a-f0-9]+)/);if (match) return match[1];match = html.match(/['"]h['"]:\s*['"]([^'"]+)['"]/);if (match) return match[1];match = html.match(/action="[^"]*[&?]h=([a-f0-9]+)/);if (match) return match[1];return null;}getCachedToken(cacheKey) {const cached = this.tokenCache.get(cacheKey);if (!cached) {return null;}const now = Date.now();if (now > cached.expires) {this.tokenCache.delete(cacheKey);return null;}return cached.token;}setCachedToken(cacheKey, token) {const expires = Date.now() + this.tokenExpiration;this.tokenCache.set(cacheKey, {token,expires,created: Date.now()});}clearTokenCache() {this.tokenCache.clear();}validateTokenFormat(token) {if (!token || typeof token !== 'string') {return false;}return /^[a-f0-9]+$/i.test(token) && token.length >= 8;}async refreshToken(villageId = null) {const village = villageId || this.api.currentVillage;const cacheKey = `token_${village}`;this.tokenCache.delete(cacheKey);return await this.getCSRFToken(village);}getCacheInfo() {const info = [];this.tokenCache.forEach((value, key) => {const timeLeft = Math.max(0, value.expires - Date.now());info.push({key,token: value.token.substring(0, 8) + '...',created: new Date(value.created).toLocaleTimeString(),expires: new Date(value.expires).toLocaleTimeString(),timeLeft: Math.round(timeLeft / 1000) + 's'});});return info;}isAuthenticated() {return !!(window.game_data && window.game_data.player && window.game_data.village);}getPlayerInfo() {if (!this.isAuthenticated()) {return null;}return {id: window.game_data.player.id,name: window.game_data.player.name,sitter: window.game_data.player.sitter,villageId: window.game_data.village.id,villageName: window.game_data.village.name,locale: window.game_data.locale,world: window.game_data.world};}}