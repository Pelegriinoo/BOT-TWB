window.AttackSystem = class AttackSystem {constructor(api, authManager, troopsManager) {this.api = api;this.auth = authManager;this.troops = troopsManager;this.attackHistory = [];this.isProcessing = false;}async prepareAttack(attackData) {const { sourceVillage, targetCoords, troops, attackType = 'attack' } = attackData;const validation = this.validateAttackData(attackData);if (!validation.valid) {throw new Error(`Dados inválidos: ${validation.reason}`);}const token = await this.auth.getCSRFToken(sourceVillage);if (!token) {throw new Error('Não foi possível obter token de autenticação');}const [x, y] = targetCoords.split('|');const formData = new FormData();formData.append('x', x);formData.append('y', y);formData.append('target_type', 'coord');formData.append('h', token);Object.entries(troops).forEach(([unit, count]) => {if (count > 0) {formData.append(unit, count.toString());}});const attackConfig = ATTACK_TYPES[attackType];if (attackConfig) {formData.append(attackConfig.param, this.getAttackButtonText(attackType));}const screenParam = attackType === 'support' ? 'mode=support' : '';const baseParams = {village: sourceVillage,screen: 'place'};if (screenParam) {baseParams.mode = 'support';}const confirmUrl = this.api.buildUrl('game.php', {...baseParams,try: 'confirm'});try {const response = await fetch(confirmUrl, {method: 'POST',body: formData});if (!response.ok) {throw new Error(`Erro HTTP ${response.status}: ${response.statusText}`);}const html = await response.text();this.api.checkForErrors(html);const confirmData = this.api.extractHiddenInputs(html);const attackInfo = this.extractAttackInfo(html);return {confirmData,token,html,attackInfo,status: STATUS_CODES.SUCCESS};} catch (error) {throw new Error(`Erro na preparação: ${error.message}`);}}async confirmAttack(sourceVillage, confirmData, token) {const formData = new FormData();formData.append('h', token);Object.entries(confirmData).forEach(([key, value]) => {if (key !== 'h') {formData.append(key, value);}});const finalUrl = this.api.buildUrl('game.php', {village: sourceVillage,screen: 'place',action: 'command',h: token});try {const response = await fetch(finalUrl, {method: 'POST',body: formData});if (!response.ok) {throw new Error(`Erro HTTP ${response.status}: ${response.statusText}`);}const html = await response.text();const success = this.checkAttackSuccess(html);if (!success.isSuccess) {throw new Error(success.reason || 'Falha na confirmação do ataque');}const resultInfo = this.extractResultInfo(html);return {success: true,...resultInfo,status: STATUS_CODES.COMPLETED};} catch (error) {throw new Error(`Erro na confirmação: ${error.message}`);}}async sendAttack(attackData) {if (this.isProcessing) {throw new Error('Outro ataque está sendo processado');}this.isProcessing = true;try {this.logAttack(attackData, STATUS_CODES.LOADING);const availableTroops = await this.troops.getAvailableTroops(attackData.sourceVillage);const validation = this.troops.validateTroopData(attackData.troops, availableTroops);if (!validation.valid) {throw new Error(`Tropas insuficientes: ${validation.reason}`);}const prepareResult = await this.prepareAttack(attackData);const confirmResult = await this.confirmAttack(attackData.sourceVillage,prepareResult.confirmData,prepareResult.token);const result = {success: true,message: `Ataque enviado para ${attackData.targetCoords}`,target: attackData.targetCoords,attackType: attackData.attackType,duration: confirmResult.duration,arrivalTime: confirmResult.arrivalTime,troops: attackData.troops,attackInfo: prepareResult.attackInfo,timestamp: new Date().toISOString()};this.logAttack({ ...attackData, result }, STATUS_CODES.SUCCESS);return result;} catch (error) {this.logAttack({ ...attackData, error: error.message }, STATUS_CODES.ERROR);return {success: false,error: error.message,target: attackData.targetCoords,timestamp: new Date().toISOString()};} finally {this.isProcessing = false;}}async sendMultipleAttacks(attacksList, options = {}) {const { delay = 1000, stopOnError = false } = options;const results = [];for (let i = 0; i < attacksList.length; i++) {const attackData = attacksList[i];try {const result = await this.sendAttack(attackData);results.push(result);if (!result.success && stopOnError) {break;}if (i < attacksList.length - 1 && delay > 0) {await this.sleep(delay);}} catch (error) {const errorResult = {success: false,error: error.message,target: attackData.targetCoords,index: i};results.push(errorResult);if (stopOnError) {break;}}}return {total: attacksList.length,successful: results.filter(r => r.success).length,failed: results.filter(r => !r.success).length,results};}validateAttackData(data) {if (!data || typeof data !== 'object') {return { valid: false, reason: 'Dados de ataque inválidos' };}if (!data.sourceVillage) {return { valid: false, reason: 'Vila de origem não especificada' };}const coordsValidation = this.api.validateCoordinates(data.targetCoords);if (!coordsValidation.valid) {return coordsValidation;}if (!data.troops || typeof data.troops !== 'object') {return { valid: false, reason: 'Tropas não especificadas' };}const troopsValidation = this.troops.validateTroopData(data.troops);if (!troopsValidation.valid) {return troopsValidation;}if (data.attackType && !ATTACK_TYPES[data.attackType]) {return { valid: false, reason: 'Tipo de ataque inválido' };}return { valid: true };}extractAttackInfo(html) {const info = {};const durationMatch = html.match(/(\d+):(\d+):(\d+)/);if (durationMatch) {info.duration = `${durationMatch[1]}:${durationMatch[2]}:${durationMatch[3]}`;const [hours, minutes, seconds] = durationMatch.slice(1).map(Number);const durationMs = (hours * 3600 + minutes * 60 + seconds) * 1000;info.arrivalTime = new Date(Date.now() + durationMs);}const targetMatch = html.match(/(\d+\|\d+)/);if (targetMatch) {info.targetCoords = targetMatch[1];}const villageNameMatch = html.match(/<span[^>]*>([^<]+)<\/span>[^<]*\(\d+\|\d+\)/);if (villageNameMatch) {info.targetVillageName = villageNameMatch[1].trim();}return info;}extractResultInfo(html) {const info = {};const durationMatch = html.match(/(\d+):(\d+):(\d+)/);if (durationMatch) {info.duration = `${durationMatch[1]}:${durationMatch[2]}:${durationMatch[3]}`;}const commandMatch = html.match(/command=(\d+)/);if (commandMatch) {info.commandId = commandMatch[1];}return info;}checkAttackSuccess(html) {const successIndicators = ['command_sent','enviado','sent','gesendet','wysłano'];const isSuccess = successIndicators.some(indicator => html.toLowerCase().includes(indicator));if (isSuccess) {return { isSuccess: true };}if (html.includes('error_box')) {const errorMatch = html.match(/<div[^>]*class="error_box"[^>]*>(.*?)<\/div>/s);if (errorMatch) {const reason = errorMatch[1].replace(/<[^>]*>/g, '').trim();return { isSuccess: false, reason };}}return { isSuccess: false, reason: 'Falha na confirmação' };}getAttackButtonText(attackType) {const locale = this.api.gameData.locale || 'pt_BR';const buttonTexts = {'pt_BR': {attack: 'Atacar',support: 'Apoiar'},'en_DK': {attack: 'Attack',support: 'Support'},'de_DE': {attack: 'Angriff',support: 'Unterstützung'}};return buttonTexts[locale]?.[attackType] || buttonTexts['pt_BR'][attackType] || 'Atacar';}logAttack(attackData, status) {const logEntry = {timestamp: new Date().toISOString(),status,sourceVillage: attackData.sourceVillage,targetCoords: attackData.targetCoords,attackType: attackData.attackType || 'attack',troops: attackData.troops,error: attackData.error,result: attackData.result};this.attackHistory.push(logEntry);if (this.attackHistory.length > 100) {this.attackHistory = this.attackHistory.slice(-100);}if (window.TWB_DEBUG) {console.log('Attack Log:', logEntry);}}getAttackHistory() {return [...this.attackHistory];}clearHistory() {this.attackHistory = [];}sleep(ms) {return new Promise(resolve => setTimeout(resolve, ms));}getAttackStats() {const total = this.attackHistory.length;const successful = this.attackHistory.filter(log => log.status === STATUS_CODES.SUCCESS).length;const failed = this.attackHistory.filter(log => log.status === STATUS_CODES.ERROR).length;return {total,successful,failed,successRate: total > 0 ? Math.round((successful / total) * 100) : 0};}}